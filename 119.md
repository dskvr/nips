# NIP-119: AND Operator in Filters

Enable `AND` within a single tag filter by using an `&` modifier in filters for indexable tags.

```
filters: {
  "kinds": [1],
  "&t": ["meme", "cat"],
  "#t": ["black", "white"]
}
// returns kind `1` events with `t` tags that have both "meme" and "cat" that have the tag "black" or "white"
```

## Rationale
- Reduce bandwidth for all, with an emphasis on mobile users: `meme AND cat` objectively consumes less bandwidth than `meme OR cat `
- Reduce clock-time for relays, indexing with `AND` is fast for all common index formats, and faster compared to `OR` for some index formats. (See section below)
- Reduce client-side caching requirements
- Reduce centralization vectors by reducing or even eliminating the need for centralized REST, GraphQL APIs or specialized relay "feed" endpoints.
- Give relays the option to be more useful at the protocol level while improving efficiency for all parties.

## Rules

- `AND` **MUST** take precedence over `OR`
- Tags used in `AND` **SHOULD NOT** be used in standard `OR` tags [`#`]
- Any tag used in `AND` **SHOULD** be ignored in `OR` 

## Considerations

- New field for `NIP-11.limitations`: `max_tags_per_and` and `max_tags_and`
- Benchmarking should be conducted to validate that bandwidth and protocol usability as benefits supercede implementation and clock-time cost. 

## Index Efficiency
| Index Type     | AND Operation Efficiency | OR Operation Efficiency | Notes |
|----------------|--------------------------|-------------------------|-------|
| B-Tree     | High                     | Moderate                | B-Tree indexes are very efficient for AND operations, especially with compound indexes. For OR operations, they are less efficient than for AND, as the database engine might need to traverse multiple paths. |
| Bitmap     | High                     | High                    | Bitmap indexes excel in both AND and OR operations, particularly for columns with low cardinality. They utilize fast bitwise operations, making them ideal for read-heavy environments. |
| Hash       | Not Applicable           | Not Applicable          | Hash indexes are designed for equality checks and do not directly support range-based queries or optimize for AND/OR operations efficiently. |
| Full-Text  | High                     | High                    | Optimized for text search, full-text indexes efficiently handle both AND and OR conditions, making them suitable for complex text queries. |